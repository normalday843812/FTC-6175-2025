---
title: Setup
description: Before you tune Pedro, there are a few simple steps you must complete.
---

import { Callout } from 'fumadocs-ui/components/callout'

## Setting your robot's mass

Your robot's mass is used to compensate for centripetal force. To set the
mass, simply add `.mass` in `FollowerConstants`. Note that the mass **must
be in kilograms**.

```java title="Constants.java"
public static FollowerConstants followerConstants = new FollowerConstants()
        .mass(5);
```

<Callout title="Tip" type="info">
  If you don't have a large enough scale to weigh your robot, you can stand on
  the scale while holding your robot and then subtract your own weight.
</Callout>

## Adding drivetrain constants

Next, we will add our drivetrain constants. These include motor names, motor
directions, and the max power. The max power must be a number from 0 to 1.

### Mecanum

If you have a mecanum drivetrain, add the following to your `Constants` class.

```java title="Constants.java"
public static MecanumConstants driveConstants = new MecanumConstants()
        .maxPower(1)
        .rightFrontMotorName("rf")
        .rightRearMotorName("rr")
        .leftRearMotorName("lr")
        .leftFrontMotorName("lf")
        .leftFrontMotorDirection(DcMotorSimple.Direction.REVERSE)
        .leftRearMotorDirection(DcMotorSimple.Direction.REVERSE)
        .rightFrontMotorDirection(DcMotorSimple.Direction.FORWARD)
        .rightRearMotorDirection(DcMotorSimple.Direction.FORWARD)
```

<Callout title="Important" type="warning">
  Make sure that your motor names and directions are correct. It's likely
  that you will have to reverse one side!
</Callout>

Then, add the mecanum drivetrain to the follower builder in `createFollower`:

```java title="Constants.java"
public static Follower createFollower(HardwareMap hardwareMap) {
        return new FollowerBuilder(followerConstants, hardwareMap)
                .pathConstraints(pathConstraints)
                .mecanumDrivetrain(driveConstants)
                .build();
}
```
---
title: Automatic Tuners
description: The four automatic tuners
---

## Forward Velocity Tuner

<Callout title="Purpose" type="info">
  The Forward Velocity Tuner determines the velocity of your robot when moving forward at full power. 
  This value is used for accurate path-following calculations in Pedro Pathing.
</Callout>

First, make sure you have enough room. By default, the robot moves 48 inches forward, but this can be
changed by navigating to the `ForwardVelocityTuner` class in `Tuning.java`. Typically larger numbers yield
better results. Then, in the Tuning OpMode, under automatic, select and start Forward Velocity Tuner. The
robot speed should ramp up until it reaches full power. It will continue moving until it has reached the set distance,
then it will abruptly stop.

Once the robot stops moving at maximum speed, one number will be displayed on telemetry:

- Velocity: The final velocity the robot achieved before stopping; this is what we want

Add the velocity to `MecanumConstants` by adding or editing the following.

```java title="Constants.java"
.xVelocity(velocity)
```

## Lateral Velocity Tuner

<Callout title="Purpose" type="info">
  The Lateral Velocity Tuner determines the velocity of your robot when moving sideways at full power. 
  This value is used for accurate path-following calculations in Pedro Pathing.
</Callout>

First, make sure you have enough room. By default, the robot moves 48 inches to the left, but this can be
changed by navigating to the `LateralVelocityTuner` class in `Tuning.java`. Typically larger numbers yield
better results. Then, in the Tuning OpMode, under automatic, select and start Lateral Velocity Tuner. The
robot speed should ramp up until it reaches full power. It will continue moving until it has reached the set distance,
then it will abruptly stop.

Once the robot stops moving at maximum speed, one number will be displayed on telemetry:

- Velocity: The final velocity the robot achieved before stopping; this is what we want

Add the velocity to `MecanumConstants` by adding or editing the following.

```java title="Constants.java"
.yVelocity(velocity)
```

## Forward Zero Power Acceleration

<Callout title="Purpose" type="info">
  Measures how your robot decelerates when moving forward and power is cut from the drivetrain. 
  This value is critical for improving motion accuracy in Pedro Pathing.
</Callout>

First, make sure you have enough space to accelerate 30 in/s forward (roughly 1 tile). You can adjust this constraint
by navigating to `ForwardZeroPowerAccelerationTuner` in `Tuning.java`. Typically values closer to your
max forward velocity yield better results. Then, in the Tuning OpMode, under automatic, select and start Forward
Zero Power Acceleration Tuner. The robot will speed up until it reaches the commanded velocity, then cut power and measure the deceleration rate.

Once the robot stops moving, one number will be displayed on telemetry:

- Forward Zero Power Acceleration (Deceleration): The deceleration rate of the robot; this is what we want

Add the above number to `FollowerConstants` by adding or editing the following.

```java title="Constants.java"
.forwardZeroPowerAcceleration(deceleration)
```

## Lateral Zero Power Acceleration

<Callout title="Purpose" type="info">
  Measures how your robot decelerates when moving lateral and power is cut from the drivetrain. 
  This value is critical for improving motion accuracy in Pedro Pathing.
</Callout>

First, make sure you have enough space to accelerate 30 in/s to the left (roughly 1 tile). You can adjust this constraint
by navigating to `LateralZeroPowerAccelerationTuner` in `Tuning.java`. Typically values closer to your
max lateral velocity yield better results. Then, in the Tuning OpMode, under automatic, select and start `Lateral 
Zero Power Acceleration Tuner`. The robot will speed up until it reaches the commanded velocity, then cut power and measure the deceleration rate.

Once the robot stops moving, one number will be displayed on telemetry:

- Lateral Zero Power Acceleration (Deceleration): The deceleration rate of the robot; this is what we want

Add the above number to `FollowerConstants` by adding or editing the following.

```java title="Constants.java"
.lateralZeroPowerAcceleration(deceleration)
```

Congratulations, you've completed all of the automatic tuners!

## Troubleshooting

If you have any problems, see the [troubleshooting page](/docs/pathing/tuning/troubleshooting).

---
title: Centripetal
description: Tuning the centripetal scaling
---

### Purpose

The centripetal force correction enables the robot to accurately follow curved paths.

### Setup

1. Open Panels. If you haven't used Panels before, you can read the documentation on [Panels Configurables](https://panels.bylazar.com/docs/com.bylazar.configurables/).
2. On your Driver Hub or Driver Station, select the `Tuning` Opmode, navigate to `Manual` and then choose `CentripetalTuner`.
3. Ensure that the timer for autonomous OpModes is **disabled.** Otherwise, the OpMode will automatically stop after 30 seconds.
4. Run the run the `CentripetalTuner` autonomous OpMode.

**WARNING: Immediately after running the `Centripetal Tuner` Opmode, the robot will move forward and left 20 inches in a curved path. Make sure you have enough space before running this opmode.**
You can adjust the distance the robot drives back and forth through Panels.

## Tuning Process
Follow this video to help you tune the centripetal scalar:

<iframe width="560" height="315" src="https://www.youtube.com/embed/728GLkqy9yY?si=YFZ0iWha6KqztOsH" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

Observe the robotâ€™s path:

- If the robot corrects towards the inside of the curve, decrease `centripetalScaling`.
- If the robot corrects towards the outside of the curve, increase `centripetalScaling`.
  Adjust the value of `centripetalScaling` within the `Tuning`-> `Follower` -> `Constants` section in Panels.

### Update Tuned values Into Your Code
1. Once you are satisfied with your `centripetalScaling`, head over to the `Constants` file.
2. Navigate to the line `.centripetalScaling(0.005)` under `followerConstants`. If you don't have this line, feel free to add it yourself.
3. Update the parameters in `.centripetalScaling(0.005)` with the `centripetalScaling` value you tuned.

## Troubleshooting
If you have any problems, see the [troubleshooting page](/docs/pathing/tuning/troubleshooting).

---
title: Drive
description: The Drive PIDF manages acceleration and braking along a path, ensuring smooth motion and minimizing overshoot.
---

## Setup

1. Open Panels. If you haven't used Panels before, you can read the documentation on the [Panels Configurables](https://panels.bylazar.com/docs/com.bylazar.configurables/).
2. On your Driver Hub or Driver Station, and connect a gamepad to it. Make sure to press "start" + "a" on the gamepad.
3. Select the `Tuning` Opmode. Use your gamepad to select the `Manual` folder. Then, select `Drive Tuner`.
4. Run the run the OpMode.

<Callout title="Warning!" type="warning">
**Immediately after running the `Drive Tuner` Opmode, the robot will move straight back and forth 40 inches. Make sure you have enough space before running this opmode.**
You can adjust the distance the robot drives back and forth through Panels. 
</Callout>

## Tuning Process

### Setting the BrakingStrength

Before tuning the Drive PIDF, we will need to set the BrakingStrength. Head over to the [deceleration page](/docs/pathing/reference/deceleration) to learn more about it.

The BrakingStrength you set in the `Constants` class will be the default BrakingStrength for all paths the robot follows.

1. Observe how the robot moves back and forth through its path.
2. Adjust the PIDF constants (`coefficientsDrivePIDF`) in the `Tuning`-> `Follower` -> `Constants` tab of Panels Configurables to ensure that the robot smoothly and accurately drives straight back and forth.

<Callout title="Tuning Tips" type="info">
  - Increasing your drive PIDF will make the robot move more quickly along the path, at the risk of more overshoot at the end of the path. 
  - Decreasing your drive PIDF will make the robot move more slowly and reduce the overshoot at the end of the path. 
  - Adjusting the `BrakingStrength` can significantly help manage how smoothly the robot decelerates as it reaches the end of its path. 
  - If the robot drives quickly during the middle of the path but abruptly slows down as it reaches the end of the path, this may be caused by the transition between the main and secondary PIDs. This problem may also be addressed through lowering the BrakingStrength. 
</Callout>
**If you do not have prior experience with tuning PIDFs, we recommend that you check out the resources provided at the bottom of the PIDF Tuners page to learn more about tuning these.**

**If you have a dual PIDF system enabled,** it is recommended to first tune the main PIDF, `coefficientsDrivePIDF` before tuning the secondary PIDF, `coefficientsSecondaryDrivePIDF`.

<Callout title="Tuning Tips" type="info">
PedroPathing now no longer integrates heading and translational PIDF correction for drive tuning, if you would like to test all three of them, navigate yourself to the `LineTest`.
</Callout>

**Warning:** After adjusting a value in Panels, **hit "enter"** in order to save it and cause the robot to correct differently. However, any values you modify through Panels **are not saved into your code!** In order to transfer the values you just tuned on Panels into your code, go to the **Update Tuned Values** section to learn more.

### Braking Start (Optional)

Braking Start determines when the robot starts breaking when global deceleration (deceleration upon the entire PathChain) is active.
Braking Start can be adjusted just like BrakingStrength.

### Feedforward Adjustments (Optional)

If additional feedforward is needed, use the feedforward term directly in the `coefficientsDrivePIDF` and/or `coefficientsSecondaryDrivePIDF` if
you are using dual PID.

- The feedforward term applies a minimum power output to the motors to compensate for the friction between the motors, wheels, and the ground.
- To tune the feedforward, set all other PIDF values to 0 and increase the Feedforward value up until the robot starts moving/jittering.

### Kalman Filter Adjustments (Optional)

The drive PID uses a Kalman filter to smooth error responses:

- Model Covariance: Default is `6`.
- Data Covariance: Default is `1`.
- A higher model covariance to data covariance ratio will cause the filter to rely on the previous output rather than the data (raw drive error).
- A lower model covariance to data covariance ratio will cause the filter to rely on the data rather than the previous output
- To modify these values, add the line `FollowerConstants.driveKalmanFilterParameters(6, 1)` in your `Constants` file and replace the parameters with the desired ones.

The drive PID also has a filter such that the derivative term is a weighted average of the
current derivative and the previous derivative.
- The default time constant `T` for the
  drive filtered PID is 0.6, meaning that the derivative output is 0.6 times the previous derivative plus 0.4
  times the current derivative.
- You can modify this value by changing the **fourth** parameter in the `drivePIDFCoefficients(P, I, D, T, F)`.

Feel free to experiment with these settings for optimal performance.

### Update Tuned values Into Your Code
1. Once you are satisfied with your drivePIDF values, head over to the `Constants` file, and navigate to the `FollowerConstants` instantiation.
2. Navigate to or add the line `.drivePIDFCoefficients(new FilteredPIDFCoefficients(0.1,0.0,0.01,0.6,0.0))`
3. Update the parameters in `new FilteredPIDFCoefficients(P, I, D, T, F)` with the `drivePIDFCoefficients` values, `P, I, D, F`, you tuned on Panels.
4. If you are using the dual PIDF system, **add the line** `.secondaryDrivePIDFCoefficients(new FilteredPIDFCoefficients(0.1,0,0.01,0.6,0.01))` and update the `secondaryDrivePIDF` values you tuned on Panels.

## Troubleshooting
If you encounter a problem while tuning the Drive PIDF, check out the [troubleshooting page](/docs/pathing/tuning/troubleshooting).

---
title: Heading
description: The heading PIDF corrects for the robot's heading while following the path.
---

### Setup

1. Open Panels. If you haven't used Panels before, you can read the documentation on the [Panels Configurables](https://panels.bylazar.com/docs/com.bylazar.configurables/).
2. On your Driver Hub or Driver Station, select the `Tuning` Opmode and then choose `HeadingTuner`.
3. Ensure that the timer for autonomous OpModes is **disabled.** Otherwise, the OpMode will automatically stop after 30 seconds.
4. Run the run the `HeadingTuner` autonomous OpMode.

**Note that while running the `Heading Tuner` OpMode, the robot will stay in place. This is intentional.**

## Tuning Process
Follow this video to help you tune the PIDF(s):

<iframe width="560" height="315" src="https://www.youtube.com/embed/-7M8puRdnfA?si=3jmMW5fJTCw5hOr_" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

1. Turn the robot left or right at varying amounts and observe how the robot turns back to its starting heading.
2. Adjust the PIDF constants (`coefficientsHeadingPIDF`) in the `Tuning`-> `Follower` -> `Constants` section of Panels Configurables to ensure that the robot can **accurately correct** back to its starting position with **minimal oscillations.** For example, if the robot has too many oscillations while correcting back to its starting position, lower the P value. On the other hand, if the robot corrects back to its starting location too slowly, increase the P value.
   **If you do not have prior experience with tuning PIDFs, we recommend that you check out the resources provided at the bottom of the PIDF Tuners page to learn more about tuning these.**

**If you have a dual PIDF system enabled,** it is recommended to first tune the main PIDF, `coefficientsHeadingPIDF`, to ensure that the robot can smoothly correct back from large errors. Then, tune the secondary PIDF, `coefficientsSecondaryHeadingPIDF`, so the robot can smoothly correct from smaller errors.

**Warning:** After adjusting a value in Panels, **hit "enter"** in order to save it and cause the robot to correct differently. However, any values you modify through Panels **are not saved into your code!** In order to transfer the values you just tuned on Panels into your code, go to the **Update Tuned Values** section to learn more.

### Feedforward Adjustments (Optional)

If additional feedforward is needed, use the feedforward term directly in the `coefficientsHeadingPIDF` and/or `coefficientsSecondaryHeadingPIDF` if
you are using dual PID.

- The feedforward term applies a minimum power output to the motors to compensate for the friction between the motors, wheels, and the ground.
- To tune the feedforward, set all other PIDF values to 0 and increase the Feedforward value up until the robot starts moving/jittering.

### Update Tuned values Into Your Code
1. Once you are satisfied with your headingPIDF values, head over to the `Constants` file, and navigate to the `FollowerConstants` instantiation.
2. Navigate to or add the line `.headingPIDFCoefficients(new PIDFCoefficients(0.1, 0, 0.01, 0))`
3. Update the parameters in `new PIDFCoefficients(0.1, 0, 0.01, 0)` with the `headingPIDFCoefficients` values, `P, I, D, F`, you tuned on Panels in that order.
4. If you are using the dual PIDF system, **add the line** `.secondaryHeadingPIDFCoefficients(new PIDFCoefficients(0.1,0,0.01,0))` and update the `secondaryHeadingPIDF` values you tuned on Panels.

## Troubleshooting
If you encounter a problem while tuning the heading PIDF, check out the [troubleshooting page](/docs/pathing/tuning/troubleshooting).

---
title: PID Tuners
description: The three PID tuners
---

Pedro Pathing relies on **Proportional-Integral-Derivative (PID)
controllers** to ensure precise path-following performance. The following pages
will walk you through tuning the various PID controllers for translational,
heading, and drive.

## Single vs. Dual PID System

In Pedro Pathing, you can choose between using one or two PID controllers for
each correction type (translational, heading, and drive).

### Single PID System

In a single PID system, a single PID is responsible for managing all errors.
This is the simplest option and is the quickest to get started with.

Since a single PID system is the default, you don't have to do anything
special to use it.

### Dual PID System

In a dual PID system, there is a **main PID** that handles larger errors and
a **secondary PID** for smaller corrections.

Advantages to using a dual PID system are:

- Better correction
- Scalable error thresholds
- Allows for more aggressive tuning

If you want to try using a dual PID system, it is recommended that you start
with drive, as it will contribute the most to a better auto.

To enable a dual PID system, set any of the following to `true` in
`FollowerConstants` in the
`Constants` file.

```java title="Constants.java"
.useSecondaryTranslationalPIDF(true)
.useSecondaryHeadingPIDF(true)
.useSecondaryDrivePIDF(true)
```

Then, tune both the main and secondary PIDs. The main PID should move the
error into the secondary PID's range without causing overshoot, and the
secondary PID should correct for small errors quickly and minimize oscillations.

## Tuning PIDs

Read the
[PID tuning page on CTRL ALT FTC](https://www.ctrlaltftc.com/the-pid-controller/tuning-methods-of-a-pid-controller)
to learn how to tune a PID controller. Addtionally, the following videos
demonstrate how to tune a PID.

<iframe className="mb-5" width="560" height="315"
src="https://www.youtube.com/embed/qKy98Cbcltw?si=8HYnqB9XWWTazdMe"
title="YouTube video player" frameBorder="0"
allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
referrerPolicy="strict-origin-when-cross-origin"
allowFullScreen></iframe>

<iframe width="560" height="315"
src="https://www.youtube.com/embed/uXnDwojRb1g?si=Zy53je8jd2naUW7a"
title="YouTube video player" frameBorder="0"
allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
referrerPolicy="strict-origin-when-cross-origin"
allowFullScreen></iframe>

---
title: Translational
description: The translational PIDF ensures the robot follows a straight path without lateral deviation.
---

## Setup

1. Open Panels. If you haven't used Panels before, you can read the documentation on the [Panels](https://panels.bylazar.com/docs/com.bylazar.configurables/).
2. On your Driver Hub or Driver Station, and connect a gamepad to it. Make sure to press "start" + "a" on the gamepad.
3. Select the `Tuning` Opmode. Use your gamepad to select the `Manual` folder. Then, select `Translational Tuner`.
4. Run the run the OpMode.

**Note that while running the `Translational Tuner` OpMode, the robot will stay in place. This is intentional.**

## Tuning Process
Follow this video to help you tune the PIDF(s):

<iframe width="560" height="315" src="https://www.youtube.com/embed/qe2eo_Mhtes?si=DMqud3FSZ2j5AmPu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

1. Push the robot left or right at varying amounts and observe how the robot corrects back to its starting position.
2. Adjust the PIDF constants (`coefficientsTranslationalPIDF`) in the `Tuning`-> `Follower` -> `Constants` section of Panels Configurables to ensure that the robot can **accurately correct** back to its starting position with **minimal oscillations.** For example, if the robot has too many oscillations while correcting back to its starting position, try lowering the P value. On the other hand, if the robot corrects back to its starting location too slowly, increase the P value.
   **If you do not have prior experience with tuning PIDFs, we recommend that you check out the resources provided at the bottom of the PIDF Tuners page to learn more about tuning these.**

**If you have a dual PIDF system enabled,** it is recommended to first tune the main PIDF, `coefficientsTranslationalPIDF`, to ensure that the robot can correct from large errors and bring it within the secondary PID's range. Then, tune the secondary PIDF, `coefficientsSecondaryTranslationalPIDF`, so the robot can smoothly correct from smaller errors and minimize oscillations.

**Note:** Don't worry if the robot doesn't correct its heading. We are only tuning for the translational PIDF: whether the robot corrects left/right appropriately.

**Warning:** After adjusting a value in Panels, **hit "enter"** in order to save it and cause the robot to correct differently. However, any values you modify through Panels **are not saved into your code!** In order to transfer the values you just tuned on Panels into your code, go to the **Update Tuned Values** section.

### Feedforward Adjustments (Optional)

If additional feedforward is needed, use the feedforward term directly in the `coefficientsTranslationalPIDF` and/or `coefficientsSecondaryTranslationalPIDF` if
you are using dual PID.

- The feedforward term applies a minimum power output to the motors to compensate for the friction between the motors, wheels, and the ground.
- To tune the feedforward, set all other PIDF values to 0 and increase the Feedforward value up until the robot starts moving/jittering.

### Update Tuned values Into Your Code
1. Once you are satisfied with your translationalPIDF values, head over to the `Constants` file, and navigate to the `FollowerConstants` instantiation.
2. Navigate to or add the line `.translationalPIDFCoefficients(new PIDFCoefficients(0.1, 0, 0.01, 0))`
3. Update the parameters in `new PIDFCoefficients(0.1, 0, 0.01, 0)` with the `translationalPIDFCoefficients` values, `P, I, D, F`, you tuned on Panels in that order.
4. If you are using the dual PIDF system, **add the line** `.secondaryTranslationalPIDFCoefficients(new PIDFCoefficients(0.1,0,0.01,0))` and update the `secondaryTranslationalPIDF` values you tuned on Panels.

## Troubleshooting
If you encounter a problem while tuning the translational PIDF, check out the [troubleshooting page](/docs/pathing/tuning/troubleshooting).

---
title: Setup
description: Before you tune Pedro, there are a few simple steps you must complete.
---

import { Callout } from 'fumadocs-ui/components/callout'

## Setting your robot's mass

Your robot's mass is used to compensate for centripetal force. To set the
mass, simply add `.mass` in `FollowerConstants`. Note that the mass **must
be in kilograms**.

```java title="Constants.java"
public static FollowerConstants followerConstants = new FollowerConstants()
        .mass(5);
```

<Callout title="Tip" type="info">
  If you don't have a large enough scale to weigh your robot, you can stand on
  the scale while holding your robot and then subtract your own weight.
</Callout>

## Adding drivetrain constants

Next, we will add our drivetrain constants. These include motor names, motor
directions, and the max power. The max power must be a number from 0 to 1.

### Mecanum

If you have a mecanum drivetrain, add the following to your `Constants` class.

```java title="Constants.java"
public static MecanumConstants driveConstants = new MecanumConstants()
        .maxPower(1)
        .rightFrontMotorName("rf")
        .rightRearMotorName("rr")
        .leftRearMotorName("lr")
        .leftFrontMotorName("lf")
        .leftFrontMotorDirection(DcMotorSimple.Direction.REVERSE)
        .leftRearMotorDirection(DcMotorSimple.Direction.REVERSE)
        .rightFrontMotorDirection(DcMotorSimple.Direction.FORWARD)
        .rightRearMotorDirection(DcMotorSimple.Direction.FORWARD)
```

<Callout title="Important" type="warning">
  Make sure that your motor names and directions are correct. It's likely
  that you will have to reverse one side!
</Callout>

Then, add the mecanum drivetrain to the follower builder in `createFollower`:

```java title="Constants.java"
public static Follower createFollower(HardwareMap hardwareMap) {
        return new FollowerBuilder(followerConstants, hardwareMap)
                .pathConstraints(pathConstraints)
                .mecanumDrivetrain(driveConstants)
                .build();
}
```

---
title: Tests
description: Validating your tuning
---

To validate your tuning, it is prudent to try running at least one of these tests.
They are runnable via the Tuning class and using the gamepad to the `Tests` folder.

## Line
Line Test is used to analyze the follower's capability of driving with all of the PIDFs active at once.
This helps determine if any PIDF(s) need adjusting.
The follower will drive 48 inches forward (two tiles) and then back to the initial position. It will loop this action.

## Triangle
Triangle Test is used to ensure that the follower is capable of straight line interpolation.
This helps determine if any PIDF(s) need adjusting.
The follower will drive in a triangle path, looping infinitely.

## Circle
Circle Test is used to ensure that the follower is capable of curved path following.
This helps determine if any PIDF(s) or if the Centripetal Scaling needs adjusting.
The follower will drive in a circle path always facing the center, looping infinitely.

## Troubleshooting
If you encounter a problem while tuning, check out the [troubleshooting page](/docs/pathing/tuning/troubleshooting) and [FAQ](/docs/pathing/faq).

---
title: Troubleshooting
description: Something went wrong?
---

import { Accordions, Accordion } from "fumadocs-ui/components/accordion";

If you have trouble during your tuning, this page may cover some common
issues that are had, just click to expand the dropdown. Otherwise, join the
[Pedro Pathing Discord](https://discord.gg/2GfC4qBP5s) and ask in `#general`
or in the `#tuning-help` channels. When asking in `#tuning-help`, please
provide additional information other than your issue. This could be a video,
your constants, telemetry outputs, logcat, or any other information.

<Accordions type="single">
  <Accordion title="Bad Localization">
    **If you're using a two wheel localizer:**

    Check whether:
    - Your encoder's `HardwareMapName` is incorrect or if the parallel &
    perpendicular odometry pods' names are swapped.
    - Your encoders directions are reversed.
    - Your IMU orientations (`LogoFacingDirection`, `UsbFacingDirection`) are
    incorrect.
    - Your odometry pod offsets are inaccurate

    Try also running `Forward Tuner` and `Lateral Tuner` more times to get more
    accurate results for `forwardTicksToInches` and `strafeTicksToInches`.

    **If you're using a three wheel localizer:**

    Check whether:
    - Your encoder's `HardwareMapName` is incorrect or if a parallel &
    perpendicular odometry pods' names are swapped (will result in robot
    rotating and translating if swapped).
    - Your encoders directions are reversed.
    - Your IMU orientations (`LogoFacingDirection`, `UsbFacingDirection`) are
    incorrect (only for Three Wheel IMU).
    - Your odometry pod offsets are inaccurate
  </Accordion>
  <Accordion title="Robot Turns 180 and Oscillates During Heading Tuner">
    This behavior is due to incorrect motor hardwareMap associations.
    Usually, this means that the front motors need to be swapped with the rear
    motors.
    Or that your odometry offsets offsets have the wrong sign.
    Try testing that the motors are correctly associated with their hardwareMap
    names by running the Tuning OpMode and navigating `Localization > Motor
    Directions` to test.
    It may require you to swap hardwareMap names or the ports in which motors
    are plugged into.

  </Accordion>
  <Accordion title="Robot Drifts Turning Drive Tuner">
    **If you're using a drive encoders, two wheel, three wheel, or OTOS,** a
    small amount of drift will happen over time, as these localizer's aren't
    perfect.
    However, the tolerance should remain manageable for the entire 30 second
    autonomous period.
  </Accordion>
  <Accordion title="Robot Movements are Too Jittery">
    Check your `brakingStrength` in `PathConstraints` and try decreasing it
    slightly. This will make the braking smoother and reduce the
    oscillations.
  </Accordion>
  <Accordion title="Robot Never Stops or Moves in the Wrong Direction">
    **Check if:**
    - Your localization is inaccurate. Run `LocalizationTest` and check:
    - when you move the robot forward, does the x-value increase?
    - when you move the robot to the left, does the y-value increase?
    - is the reported heading accurate?
    If not, head over back to the localization section and double check your
    steps. Ensure that your localization is fully accurate before tuning your
    PIDFs and running automatic tuners.
    - Your motor directions are reversed.
    - Your motor configurations are incorrect.
  </Accordion>
  <Accordion
    title="Robot Never Moves During TranslationalTuner or HeadingTuner">
    **If you are tuning for Translational or Heading PIDF, it is intentional
    that the robot doesn't initially move.**
    However, if you push/turn the robot and it still doesn't move, check whether
    your P value in the PIDF is too low. Increasing it may give more power for
    your robot to correct back to its original position.
  </Accordion>
  <Accordion title="Cannot See the Constants in Panels">
    If the Tuning class dropdown in the Panels Configurables is empty, double
    check that you have selected an OpMode in the Tuning OpMode using the
    gamepad before reloading the Panels website. The Panels website is accessible at the ip address
    `192.168.43.1:8001` when connected to robot wifi.
  </Accordion>
</Accordions>




